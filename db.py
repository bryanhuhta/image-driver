from typing import NamedTuple, Optional
import random
import sqlite3
import time


class Metadata(NamedTuple):
    id: Optional[int] = None
    number: Optional[int] = None
    group: Optional[int] = None
    min_image_index: Optional[int] = None
    max_image_index: Optional[int] = None


class Database:
    def __init__(self, path: str):
        self._path = path
        self._conn = None

    def __enter__(self):
        self._conn = sqlite3.connect(self._path)
        c = self._conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS metadata (
                id              INTEGER PRIMARY KEY NOT NULL,
                number          INTEGER NOT NULL,
                "group"         INTEGER NOT NULL,
                min_image_index INTEGER NOT NULL,
                max_image_index INTEGER NOT NULL
            )
        ''')
        self._conn.commit()
        return self

    def __exit__(self, type, value, traceback):
        self._conn.commit()
        self._conn.close()

    def add(self, m: Metadata) -> Metadata:
        c = self._conn.cursor()
        # Insert everything but the id, it's generated by the database.
        c.execute('''
            INSERT INTO metadata (
                number,
                "group",
                min_image_index,
                max_image_index
            ) VALUES (?, ?, ?, ?)
        ''', m[1:])
        return self.get(c.lastrowid)

    def get(self, id: int) -> Metadata:
        c = self._conn.cursor()
        c.execute('''
            SELECT
                id,
                number,
                "group",
                min_image_index,
                max_image_index
            FROM
                metadata
            WHERE
                id = ?
        ''', (id,))
        return Metadata(*c.fetchone())

    def update(self, id: int, m: Metadata) -> Metadata:
        c = self._conn.cursor()
        # Dynamically build sql query to do an update.
        sql = '''UPDATE metadata SET {} WHERE id = ?'''.format(",".join([
            f'{k}={v}'
            for k, v
            in m._asdict().items()
            if k != 'id' and v is not None  # Don't update the primary key.
        ]))
        c.execute(sql, (id,))
        return self.get(c.lastrowid)

    def delete(self, id: int) -> None:
        c = self._conn.cursor()
        c.execute('''DELETE FROM metadata WHERE id = ?''', (id,))
